<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of slparseprops</title>
  <meta name="keywords" content="slparseprops">
  <meta name="description" content="SLPARSEPROPS Parses input parameters">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">sltoolbox</a> &gt; <a href="index.html">utils</a> &gt; slparseprops.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for sltoolbox\utils&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>slparseprops
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>SLPARSEPROPS Parses input parameters</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function P = slparseprops(P0, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">SLPARSEPROPS Parses input parameters

 $ Syntax $
   - P = slparseprops(P0, property_struct)
   - P = slparseprops(P0, property_name1, property_value1, ...)

 $ Syntax $
   - P = slparseprops(P0, property_struct) parses the properties from a 
     property structure. The structure has multiple entries, with the 
     property names as field names, and the property values are corresponding
     values. 

   - P = slparseprops(P0, property_name1, property_value1, ...) parses
     the properties from property list. The list are a argument list with
     the form of multiple pairs of property names and corresponding values.

 $ Remarks $
   - The P0 specifies the default values of properties. All properties 
     that can be set should appear in P0. If some properties specified in
     following arguments are not included in P0, an error will be raised.

   - Passing arguments in the way of property specification is a convenient
     method when multiple values need to be input. The user can only change
     some properties, while leaving others being in their default values.
     With this function, the function composer can design the function
     interfaces in the following form: func(main_parameters, varargin), and
     use parseprops(P0, varargin{:}) to parse the properties specified in the
     extra arguments.
         
 $ History $
   - Created by Dahua Lin on Dec 19th, 2005
   - Modified by Dahua Lin, on Aug 27, 2006
       - enhance the compatibility with older version of Matlab</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../sltoolbox/ExpDL/edl_logerror.html" class="code" title="function edl_logerror(caller, err, logger, varargin)">edl_logerror</a>	EDL_LOGERROR Logs an error into logger</li><li><a href="../../sltoolbox/ExpDL/edl_readexpdefs.html" class="code" title="function ED = edl_readexpdefs(filename)">edl_readexpdefs</a>	EDL_READEXPDEFS Reads in an experiment definition from XML file</li><li><a href="../../sltoolbox/ann/annsearch.html" class="code" title="function [nnidx, dists] = annsearch(X0, X, k, varargin)">annsearch</a>	ANNSEARCH Approximate Nearest Neighbor Search</li><li><a href="../../sltoolbox/cluster/slkmeans.html" class="code" title="function [means, labels] = slkmeans(X, varargin)">slkmeans</a>	SLKMEANS Performs K-Means Clustering on samples</li><li><a href="../../sltoolbox/cluster/slkmeansex.html" class="code" title="function [centers, labels, info] = slkmeansex(X, n, estfunctor, clsfunctor, varargin)">slkmeansex</a>	SLKMEANSEX Performs Generalized K-means</li><li><a href="../../sltoolbox/discrete/slvechist.html" class="code" title="function H = slvechist(X0, X, varargin)">slvechist</a>	SLVECHIST Makes the histogram on prototype vectors by voting</li><li><a href="../../sltoolbox/discrete/slvote.html" class="code" title="function H = slvote(models, m, samples, n, evalfunctor, countrule, varargin)">slvote</a>	SLVOTE Builds histogram by voting (or fuzzy voting)</li><li><a href="../../sltoolbox/fileio/@sllog/sllog.html" class="code" title="function logger = sllog(varargin)">sllog</a>	SLLOG Constructs a logger</li><li><a href="../../sltoolbox/fileio/slchangefilepart.html" class="code" title="function newfp = slchangefilepart(fp, varargin)">slchangefilepart</a>	SLCHANGEFILEPART Changes some parts of the file path</li><li><a href="../../sltoolbox/graph/sladjmat.html" class="code" title="function A = sladjmat(G, varargin)">sladjmat</a>	SLADJMAT Constructs the adjacency matrix representation of a graph</li><li><a href="../../sltoolbox/graph/slaffinitymat.html" class="code" title="function A = slaffinitymat(X, X2, nnparams, varargin)">slaffinitymat</a>	SLAFFINITYMAT Constructs an affinity matrix</li><li><a href="../../sltoolbox/graph/sledges2adjmat.html" class="code" title="function A = sledges2adjmat(n, nt, edges, varargin)">sledges2adjmat</a>	SLEDGES2ADJMAT Creates an adjacency matrix from edge set</li><li><a href="../../sltoolbox/graph/slfindnn.html" class="code" title="function [nnidx, dists] = slfindnn(X0, X, method, varargin)">slfindnn</a>	SLFINDNN Finds the nearest neighbors using specified strategy</li><li><a href="../../sltoolbox/graph/slnngraph.html" class="code" title="function G = slnngraph(X, X2, nnparams, varargin)">slnngraph</a>	SLNNGRAPH Constructs a nearest neighborhood based graph</li><li><a href="../../sltoolbox/graph/slpwgraph.html" class="code" title="function G = slpwgraph(Xs, Xt, n, nt, evalfunctor, varargin)">slpwgraph</a>	SLVALGRAPH Constructs a graph by computing values between nodes pairwisely</li><li><a href="../../sltoolbox/graph/slpwmetricgraph.html" class="code" title="function G = slpwmetricgraph(X, varargin)">slpwmetricgraph</a>	SLPWMETRICGRAPH Constructs a graph based on pairwise metrics</li><li><a href="../../sltoolbox/imgproc/slapplyfilterband.html" class="code" title="function fimgs = slapplyfilterband(imgs, filterband, filtersize, varargin)">slapplyfilterband</a>	SLAPPLYFILTERBAND Applies filter band to filter images in batch</li><li><a href="../../sltoolbox/imgproc/slpixneighbors.html" class="code" title="function [R, pixinds] = slpixneighbors(img, filtersize, varargin)">slpixneighbors</a>	SLPIXNEIGHBORS Extracts the neighborhood of pixels from an image</li><li><a href="../../sltoolbox/kernel/slkernelfea.html" class="code" title="function Y = slkernelfea(X, X0, kparams, varargin)">slkernelfea</a>	SLKERNELFEA Extracts kernelized mapped features</li><li><a href="../../sltoolbox/kernel/slkfd.html" class="code" title="function A = slkfd(K, nums, varargin)">slkfd</a>	SLKFD Perform Kernelized Fisher Discriminant Analysis</li><li><a href="../../sltoolbox/kernel/slkpca.html" class="code" title="function [A, evs] = slkpca(K0, varargin)">slkpca</a>	SLPCA Learns a Kernel PCA model from training samples</li><li><a href="../../sltoolbox/learn/sliterproc.html" class="code" title="function [objects, info] = sliterproc(objects, iterfunctor, cmpfunctor, hasrecord, varargin)">sliterproc</a>	SLITERPROC Runs a general iterative process</li><li><a href="../../sltoolbox/learn/slproglearn.html" class="code" title="function [models, info] = slproglearn(source, getter, learnfunctor, varargin)">slproglearn</a>	SLPROGLEARN Performs Progressive Learning from sample source</li><li><a href="../../sltoolbox/learn/slreevallearn.html" class="code" title="function [models, Q, info] = slreevallearn(models, Q, data, estfunctor, evalfunctor, cmpfunctor, varargin)">slreevallearn</a>	SLREEVALLEARN Performs an iterative learning based on re-evaluation</li><li><a href="../../sltoolbox/manifold/slgembed.html" class="code" title="function [Y, spectrum] = slgembed(G, Gc, d, fm, varargin)">slgembed</a>	SLGEMBED Solves the general graph-based embedding</li><li><a href="../../sltoolbox/manifold/slnbreconweights.html" class="code" title="function WG = slnbreconweights(X0, X, G, varargin)">slnbreconweights</a>	SLNBRECONWEIGHTS Solve the optimal reconstruction weights on given neighbors</li><li><a href="../../sltoolbox/regression/sllinreg.html" class="code" title="function A = sllinreg(X, Y, varargin)">sllinreg</a>	SLLINREG Performs Multivariate Linear Regression and Ridge Regression</li><li><a href="../../sltoolbox/regression/sllogistreg.html" class="code" title="function [A, b, props, info] = sllogistreg(X, nums, varargin)">sllogistreg</a>	SLLOGISTREG Performs Multivariate Logistic Regression</li><li><a href="../../sltoolbox/stat/slfmm.html" class="code" title="function [S, cw, pp, info] = slfmm(X, n, estfunctor, evalfunctor, varargin)">slfmm</a>	SLFMM Learns a Finite Mixture Model (FMM)</li><li><a href="../../sltoolbox/stat/slgausscomb.html" class="code" title="function GS = slgausscomb(varargin)">slgausscomb</a>	SLGAUSSCOMB Collects the means and variances/covariances to form GS</li><li><a href="../../sltoolbox/stat/slgaussest.html" class="code" title="function GS = slgaussest(X, varargin)">slgaussest</a>	SLGAUSSEST Estimates the Gaussian models from samples</li><li><a href="../../sltoolbox/stat/slgausspdf.html" class="code" title="function P = slgausspdf(GS, X, varargin)">slgausspdf</a>	SLGAUSSPDF Computes the probability density of Gaussian models</li><li><a href="../../sltoolbox/stat/slgmm.html" class="code" title="function [GS, pp, info] = slgmm(X, varargin)">slgmm</a>	SLGMM Learns Gaussian Mixture model from samples</li><li><a href="../../sltoolbox/stat/slregcov.html" class="code" title="function Crs = slregcov(Cs, varargin)">slregcov</a>	SLREGCOV Regularizes covariance matrices</li><li><a href="../../sltoolbox/stat/slwhiten_from_samples.html" class="code" title="function W = slwhiten_from_samples(X, varargin)">slwhiten_from_samples</a>	SLWHITEN_FROM_SAMPLES Compute the whitening matrix from sample matrix</li><li><a href="../../sltoolbox/subspace/slcopca.html" class="code" title="function [P1, P2, spectrum] = slcopca(X1, X2, d, varargin)">slcopca</a>	SLCOPCA Performs Coupled PCA Learning</li><li><a href="../../sltoolbox/subspace/sldlda.html" class="code" title="function T = sldlda(X, nums, varargin)">sldlda</a>	SLDLDA Performs Direct Linear Discriminant Analysis</li><li><a href="../../sltoolbox/subspace/slfld.html" class="code" title="function T = slfld(X, nums, varargin)">slfld</a>	SLFLD Performs Fisher Linear Discriminant Analysis</li><li><a href="../../sltoolbox/subspace/slgbfe.html" class="code" title="function T = slgbfe(X, G, Gc, dy, fm, varargin)">slgbfe</a>	SLGBFE Performs Graph-based Feature Extraction Learning</li><li><a href="../../sltoolbox/subspace/sllda.html" class="code" title="function T = sllda(X, nums, method, varargin)">sllda</a>	SLLDA Trains a Linear Discriminant Model using specified method</li><li><a href="../../sltoolbox/subspace/slnlda.html" class="code" title="function T = slnlda(X, nums, varargin)">slnlda</a>	SLNLDA Performs Nullspace-based Linear Discriminant Analysis</li><li><a href="../../sltoolbox/subspace/slpca.html" class="code" title="function S = slpca(X, varargin)">slpca</a>	SLPCA Learns a PCA model from training samples</li><li><a href="../../sltoolbox/subspace/slscatter.html" class="code" title="function S = slscatter(X, type, varargin)">slscatter</a>	SLSCATTER Compute the scatter matrix</li><li><a href="../../sltoolbox/subspace_ex/sl2dpcaex.html" class="code" title="function [Mm, PL, PR, info] = sl2dpcaex(data, matsiz, n, method, varargin)">sl2dpcaex</a>	SL2DPCAEX Learns Extended 2D PCA on a set of matrix samples</li><li><a href="../../sltoolbox/subspace_ex/slarrmean.html" class="code" title="function arrMean = slarrmean(data, arrsiz, n, varargin)">slarrmean</a>	SLARRMEAN Computes the mean of a set of arrays</li><li><a href="../../sltoolbox/subspace_ex/slpartitionpca.html" class="code" title="function slpartitionpca(data, arrsiz, n, ps, filepath, varargin)">slpartitionpca</a>	SLPARTITIONPCA Performs Partition-based PCA and saves the models</li><li><a href="../../sltoolbox/text/slcompresstext.html" class="code" title="function Tc = slcompresstext(T, varargin)">slcompresstext</a>	SLCOMPRESSTEXT Compresses a cell array of text</li><li><a href="slclassify.html" class="code" title="function [decisions, decscores] = slclassify(scores, clabels, op, varargin)">slclassify</a>	SLCLASSIFY Classifies a set of samples according to final scores</li><li><a href="slclassify_blks.html" class="code" title="function [decisions, decscores] = slclassify_blks(scores, n, blocks, clabels, op, varargin)">slclassify_blks</a>	SLCLASSIFY_BLKS Classifies samples according to blockwise scores</li><li><a href="slsharedisp_attach.html" class="code" title="function slsharedisp_attach(name, varargin)">slsharedisp_attach</a>	SLSHAREDISP_ATTACH Attachs to global display options</li><li><a href="../../sltoolbox/xmlkits/xml_getattribs.html" class="code" title="function A = xml_getattribs(xelem, varargin)">xml_getattribs</a>	XML_GETATTRIBS Constructs an attribte struct from an XML element</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function P = parse_props_from_struct(P0, S)</a></li><li><a href="#_sub2" class="code">function P = parse_props_from_arglist(P0, args)</a></li><li><a href="#_sub3" class="code">function check_names(P0, names)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function P = slparseprops(P0, varargin)</a>
0002 <span class="comment">%SLPARSEPROPS Parses input parameters</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% $ Syntax $</span>
0005 <span class="comment">%   - P = slparseprops(P0, property_struct)</span>
0006 <span class="comment">%   - P = slparseprops(P0, property_name1, property_value1, ...)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% $ Syntax $</span>
0009 <span class="comment">%   - P = slparseprops(P0, property_struct) parses the properties from a</span>
0010 <span class="comment">%     property structure. The structure has multiple entries, with the</span>
0011 <span class="comment">%     property names as field names, and the property values are corresponding</span>
0012 <span class="comment">%     values.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%   - P = slparseprops(P0, property_name1, property_value1, ...) parses</span>
0015 <span class="comment">%     the properties from property list. The list are a argument list with</span>
0016 <span class="comment">%     the form of multiple pairs of property names and corresponding values.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% $ Remarks $</span>
0019 <span class="comment">%   - The P0 specifies the default values of properties. All properties</span>
0020 <span class="comment">%     that can be set should appear in P0. If some properties specified in</span>
0021 <span class="comment">%     following arguments are not included in P0, an error will be raised.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%   - Passing arguments in the way of property specification is a convenient</span>
0024 <span class="comment">%     method when multiple values need to be input. The user can only change</span>
0025 <span class="comment">%     some properties, while leaving others being in their default values.</span>
0026 <span class="comment">%     With this function, the function composer can design the function</span>
0027 <span class="comment">%     interfaces in the following form: func(main_parameters, varargin), and</span>
0028 <span class="comment">%     use parseprops(P0, varargin{:}) to parse the properties specified in the</span>
0029 <span class="comment">%     extra arguments.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% $ History $</span>
0032 <span class="comment">%   - Created by Dahua Lin on Dec 19th, 2005</span>
0033 <span class="comment">%   - Modified by Dahua Lin, on Aug 27, 2006</span>
0034 <span class="comment">%       - enhance the compatibility with older version of Matlab</span>
0035 <span class="comment">%</span>
0036 
0037 <span class="keyword">if</span> nargin == 1
0038     P = P0;
0039 <span class="keyword">elseif</span> nargin == 2
0040     <span class="keyword">if</span> isempty(varargin{1})
0041         P = P0;
0042     <span class="keyword">elseif</span> isstruct(varargin{1})
0043         P = <a href="#_sub1" class="code" title="subfunction P = parse_props_from_struct(P0, S)">parse_props_from_struct</a>(P0, varargin{1});
0044     <span class="keyword">else</span>
0045         error(<span class="string">'sltoolbox:invalidarg'</span>, <span class="keyword">...</span>
0046             <span class="string">'Invalid input arguments for properties specification'</span>);
0047     <span class="keyword">end</span>
0048 <span class="keyword">else</span>
0049     n = length(varargin);
0050     nitems = n / 2;
0051     <span class="keyword">if</span> nitems ~= floor(nitems)  <span class="comment">% not an integer</span>
0052         error(<span class="string">'sltoolbox:invalidarg'</span>, <span class="keyword">...</span>
0053             <span class="string">'Invalid input arguments for properties specification'</span>);
0054     <span class="keyword">end</span>
0055     args = reshape(varargin, [2, nitems]);
0056     P = <a href="#_sub2" class="code" title="subfunction P = parse_props_from_arglist(P0, args)">parse_props_from_arglist</a>(P0, args);
0057 <span class="keyword">end</span>
0058 
0059 
0060 <span class="comment">%%------------ parse functions  -----------------</span>
0061 
0062 <a name="_sub1" href="#_subfunctions" class="code">function P = parse_props_from_struct(P0, S)</a>
0063 
0064 s_names = fieldnames(S);
0065 <a href="#_sub3" class="code" title="subfunction check_names(P0, names)">check_names</a>(P0, s_names);
0066 
0067 n = length(s_names);
0068 P = P0;
0069 <span class="keyword">for</span> i = 1 : n
0070     curname = s_names{i};
0071     P.(curname) = S.(curname);
0072 <span class="keyword">end</span>
0073 
0074 
0075 <a name="_sub2" href="#_subfunctions" class="code">function P = parse_props_from_arglist(P0, args)</a>
0076 
0077 a_names = args(1, :);
0078 <a href="#_sub3" class="code" title="subfunction check_names(P0, names)">check_names</a>(P0, a_names);
0079 
0080 n = length(a_names);
0081 P = P0;
0082 <span class="keyword">for</span> i = 1 : n
0083     curname = a_names{i};
0084     P.(curname) = args{2, i};
0085 <span class="keyword">end</span>
0086 
0087 
0088 
0089 <a name="_sub3" href="#_subfunctions" class="code">function check_names(P0, names)</a>
0090 
0091 n = length(names);
0092 <span class="keyword">for</span> i = 1 : n
0093     <span class="keyword">if</span> ~ischar(names{i})
0094         error(<span class="string">'Encounter a non-char property name'</span>);
0095     <span class="keyword">end</span>
0096 <span class="keyword">end</span>
0097 
0098 <span class="keyword">for</span> i = 1 : n
0099     <span class="keyword">if</span> ~isfield(P0, names{i})
0100         error(<span class="string">'The property name %s is invalid'</span>, names{i});
0101     <span class="keyword">end</span>
0102 <span class="keyword">end</span>
0103 
0104 
0105 
0106 
0107 
0108 
0109     
0110     
0111     
0112 
0113</pre></div>
<hr><address>Generated on Wed 20-Sep-2006 12:43:11 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>