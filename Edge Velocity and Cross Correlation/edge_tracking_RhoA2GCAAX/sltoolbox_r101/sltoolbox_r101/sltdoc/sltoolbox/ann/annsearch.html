<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of annsearch</title>
  <meta name="keywords" content="annsearch">
  <meta name="description" content="ANNSEARCH Approximate Nearest Neighbor Search">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">sltoolbox</a> &gt; <a href="index.html">ann</a> &gt; annsearch.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for sltoolbox\ann&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>annsearch
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>ANNSEARCH Approximate Nearest Neighbor Search</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [nnidx, dists] = annsearch(X0, X, k, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">ANNSEARCH Approximate Nearest Neighbor Search

 $ Syntax $
   - nnidx = annsearch(X0, [], k)
   - nnidx = annsearch(X0, X, k)
   - nnidx = annsearch(X0, [], k, ...)
   - nnidx = annsearch(X0, X, k, ...)
   - [nnidx, dists] = annsearch(...)

 $ Arguments $
   - X0:       the matrix of points for constructing the KD tree
   - X:        the matrix of points for query
   - k:        the number of neighbors for each query point
   - nnidx:    the indices of neighboring points
   - dists:    the distances between the query points to their neighbors

 $ Description $
   - nnidx = annsearch(X0, [], k) approximately searches the neighboring
     points of each point of X0 within X0. In the findings, the query
     point itself is excluded from its neighbor set. k non-trivial 
     neighbors for each query point is searched.
   
   - nnidx = annsearch(X0, X, k) approximately searches the neighbors of
     points in X within the point set specified by X0. Note that even
     though there are points in X0 which are exactly some point in X, they
     will not be excluded from the results.

   - nnidx = annsearch(X0, [], k, ...)
   - nnidx = annsearch(X0, X, k, ...) conducts the search with
     user-customized options. The options that can be set are given
     as follows:
     \*
     \t  Table 1. Options for ANN search
     \h     name       &amp;      description      \\
           'errbound'  &amp;  The allowable upper bound on error (default = 0) \\
           'split'     &amp;  The rule of splitting (default = 'suggest') \\
           'search'    &amp;  The search method (default = 'normal') \\
     \*
    There are following splitting rule in constructing the KD tree:
     \*
     \t  Table 2. The Splitting rules for KD tree construction
     \h     name        &amp;   description   \\
            'std'       &amp;  the standard optimized kd-splitting rule \\
            'midpt'     &amp;  the midpoint splitting rule \\
            'fair'      &amp;  the fair splitting rule \\
            'sl_midpt'  &amp;  the sliding midpoint splitting rule \\
            'sl_fair'   &amp;  the sliding fair splitting rule \\
            'suggest'   &amp;  the author's suggestion for best (default) \\
     \*
   There are following search methods:
     \*
     \t  Table 3. The search methods
     \h     name       &amp;     description  \\
            'normal'   &amp;    the normal search method (default) \\
            'priority' &amp;    the priority search method
     \*

   - [nnidx, dists] = annsearch(...) also returns the distances between
     the query points and their neighbors.

 $ Remarks $
   - In X0 or X, each column represents a sample point.
   - If there are n points in the query set, then both nnidx and dists
     would be k x n matrix, with each column recording the neighbor
     information about the corresponding point.

 $ History $
   - Created by Dahua Lin on Apr 21, 2006</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../sltoolbox/utils/slparseprops.html" class="code" title="function P = slparseprops(P0, varargin)">slparseprops</a>	SLPARSEPROPS Parses input parameters</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../sltoolbox/cluster/slkmeans.html" class="code" title="function [means, labels] = slkmeans(X, varargin)">slkmeans</a>	SLKMEANS Performs K-Means Clustering on samples</li><li><a href="../../sltoolbox/discrete/slvechist.html" class="code" title="function H = slvechist(X0, X, varargin)">slvechist</a>	SLVECHIST Makes the histogram on prototype vectors by voting</li><li><a href="../../sltoolbox/graph/slfindnn.html" class="code" title="function [nnidx, dists] = slfindnn(X0, X, method, varargin)">slfindnn</a>	SLFINDNN Finds the nearest neighbors using specified strategy</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function id = get_splitrule_id(s)</a></li><li><a href="#_sub2" class="code">function id = get_searchmethod_id(s)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [nnidx, dists] = annsearch(X0, X, k, varargin)</a>
0002 <span class="comment">%ANNSEARCH Approximate Nearest Neighbor Search</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% $ Syntax $</span>
0005 <span class="comment">%   - nnidx = annsearch(X0, [], k)</span>
0006 <span class="comment">%   - nnidx = annsearch(X0, X, k)</span>
0007 <span class="comment">%   - nnidx = annsearch(X0, [], k, ...)</span>
0008 <span class="comment">%   - nnidx = annsearch(X0, X, k, ...)</span>
0009 <span class="comment">%   - [nnidx, dists] = annsearch(...)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% $ Arguments $</span>
0012 <span class="comment">%   - X0:       the matrix of points for constructing the KD tree</span>
0013 <span class="comment">%   - X:        the matrix of points for query</span>
0014 <span class="comment">%   - k:        the number of neighbors for each query point</span>
0015 <span class="comment">%   - nnidx:    the indices of neighboring points</span>
0016 <span class="comment">%   - dists:    the distances between the query points to their neighbors</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% $ Description $</span>
0019 <span class="comment">%   - nnidx = annsearch(X0, [], k) approximately searches the neighboring</span>
0020 <span class="comment">%     points of each point of X0 within X0. In the findings, the query</span>
0021 <span class="comment">%     point itself is excluded from its neighbor set. k non-trivial</span>
0022 <span class="comment">%     neighbors for each query point is searched.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   - nnidx = annsearch(X0, X, k) approximately searches the neighbors of</span>
0025 <span class="comment">%     points in X within the point set specified by X0. Note that even</span>
0026 <span class="comment">%     though there are points in X0 which are exactly some point in X, they</span>
0027 <span class="comment">%     will not be excluded from the results.</span>
0028 <span class="comment">%</span>
0029 <span class="comment">%   - nnidx = annsearch(X0, [], k, ...)</span>
0030 <span class="comment">%   - nnidx = annsearch(X0, X, k, ...) conducts the search with</span>
0031 <span class="comment">%     user-customized options. The options that can be set are given</span>
0032 <span class="comment">%     as follows:</span>
0033 <span class="comment">%     \*</span>
0034 <span class="comment">%     \t  Table 1. Options for ANN search</span>
0035 <span class="comment">%     \h     name       &amp;      description      \\</span>
0036 <span class="comment">%           'errbound'  &amp;  The allowable upper bound on error (default = 0) \\</span>
0037 <span class="comment">%           'split'     &amp;  The rule of splitting (default = 'suggest') \\</span>
0038 <span class="comment">%           'search'    &amp;  The search method (default = 'normal') \\</span>
0039 <span class="comment">%     \*</span>
0040 <span class="comment">%    There are following splitting rule in constructing the KD tree:</span>
0041 <span class="comment">%     \*</span>
0042 <span class="comment">%     \t  Table 2. The Splitting rules for KD tree construction</span>
0043 <span class="comment">%     \h     name        &amp;   description   \\</span>
0044 <span class="comment">%            'std'       &amp;  the standard optimized kd-splitting rule \\</span>
0045 <span class="comment">%            'midpt'     &amp;  the midpoint splitting rule \\</span>
0046 <span class="comment">%            'fair'      &amp;  the fair splitting rule \\</span>
0047 <span class="comment">%            'sl_midpt'  &amp;  the sliding midpoint splitting rule \\</span>
0048 <span class="comment">%            'sl_fair'   &amp;  the sliding fair splitting rule \\</span>
0049 <span class="comment">%            'suggest'   &amp;  the author's suggestion for best (default) \\</span>
0050 <span class="comment">%     \*</span>
0051 <span class="comment">%   There are following search methods:</span>
0052 <span class="comment">%     \*</span>
0053 <span class="comment">%     \t  Table 3. The search methods</span>
0054 <span class="comment">%     \h     name       &amp;     description  \\</span>
0055 <span class="comment">%            'normal'   &amp;    the normal search method (default) \\</span>
0056 <span class="comment">%            'priority' &amp;    the priority search method</span>
0057 <span class="comment">%     \*</span>
0058 <span class="comment">%</span>
0059 <span class="comment">%   - [nnidx, dists] = annsearch(...) also returns the distances between</span>
0060 <span class="comment">%     the query points and their neighbors.</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% $ Remarks $</span>
0063 <span class="comment">%   - In X0 or X, each column represents a sample point.</span>
0064 <span class="comment">%   - If there are n points in the query set, then both nnidx and dists</span>
0065 <span class="comment">%     would be k x n matrix, with each column recording the neighbor</span>
0066 <span class="comment">%     information about the corresponding point.</span>
0067 <span class="comment">%</span>
0068 <span class="comment">% $ History $</span>
0069 <span class="comment">%   - Created by Dahua Lin on Apr 21, 2006</span>
0070 <span class="comment">%</span>
0071 
0072 <span class="comment">%% parse and verify arguments</span>
0073 
0074 <span class="comment">% for argument number</span>
0075 <span class="keyword">if</span> nargin &lt; 3
0076     error(<span class="string">'annerror:invalidarg'</span>, <span class="keyword">...</span>
0077         <span class="string">'The number of input arguments should not be less than 3 for annsearch'</span>);
0078 <span class="keyword">end</span>
0079 <span class="keyword">if</span> nargout == 0
0080     <span class="keyword">return</span>;
0081 <span class="keyword">elseif</span> nargout &gt; 2
0082     error(<span class="string">'annerror:invalidarg'</span>, <span class="keyword">...</span>
0083         <span class="string">'The number of output arguments should not be larger than 2 for annsearch'</span>);
0084 <span class="keyword">end</span>
0085 
0086 <span class="comment">% for base-target relation</span>
0087 <span class="keyword">if</span> ~isempty(X)
0088     exclude_self = false;
0089 <span class="keyword">else</span>
0090     X = X0;
0091     k = k + 1;
0092     exclude_self = true;
0093 <span class="keyword">end</span>
0094 
0095 <span class="comment">% for sizes</span>
0096 [d, n0] = size(X0);
0097 <span class="keyword">if</span> size(X, 1) ~= d
0098     error(<span class="string">'annerror:invalidarg'</span>, <span class="keyword">...</span>
0099         <span class="string">'The dimension of training and query points should be consistent'</span>);
0100 <span class="keyword">end</span>
0101 <span class="keyword">if</span> k &gt;= n0
0102     error(<span class="string">'annerror:invalidarg'</span>, <span class="keyword">...</span>
0103         <span class="string">'The value k (neighborhood size) should be less than n0, the size of the whole set'</span>);
0104 <span class="keyword">end</span>
0105 
0106 <span class="comment">% for options</span>
0107 opts.errbound = 0;
0108 opts.split = <span class="string">'suggest'</span>;
0109 opts.search = <span class="string">'normal'</span>;
0110 opts = <a href="../../sltoolbox/utils/slparseprops.html" class="code" title="function P = slparseprops(P0, varargin)">slparseprops</a>(opts, varargin{:});
0111 
0112 
0113 
0114 <span class="comment">%% invoke the wrapped core function</span>
0115 
0116 <span class="keyword">if</span> nargout == 1
0117 
0118     nnidx = annsearch_wrapper( <span class="keyword">...</span>
0119         X0, <span class="keyword">...</span>
0120         X, <span class="keyword">...</span>
0121         k, <span class="keyword">...</span>
0122         opts.errbound, <span class="keyword">...</span>
0123         <a href="#_sub1" class="code" title="subfunction id = get_splitrule_id(s)">get_splitrule_id</a>(opts.split), <span class="keyword">...</span>
0124         <a href="#_sub2" class="code" title="subfunction id = get_searchmethod_id(s)">get_searchmethod_id</a>(opts.search));
0125 
0126 <span class="keyword">else</span>
0127     
0128     [nnidx, dists] = annsearch_wrapper( <span class="keyword">...</span>
0129         X0, <span class="keyword">...</span>
0130         X, <span class="keyword">...</span>
0131         k, <span class="keyword">...</span>
0132         opts.errbound, <span class="keyword">...</span>
0133         <a href="#_sub1" class="code" title="subfunction id = get_splitrule_id(s)">get_splitrule_id</a>(opts.split), <span class="keyword">...</span>
0134         <a href="#_sub2" class="code" title="subfunction id = get_searchmethod_id(s)">get_searchmethod_id</a>(opts.search));
0135 
0136 <span class="keyword">end</span>
0137 
0138 <span class="comment">%% post-processing</span>
0139 
0140 <span class="keyword">if</span> exclude_self
0141     nnidx = nnidx(2:<span class="keyword">end</span>, :);
0142     
0143     <span class="keyword">if</span> nargout &gt;= 2
0144         dists = dists(2:<span class="keyword">end</span>, :);
0145     <span class="keyword">end</span>
0146 <span class="keyword">end</span>
0147 
0148 nnidx = nnidx + 1;  <span class="comment">% from zero-based to one-based</span>
0149 
0150 <span class="keyword">if</span> nargout &gt;= 2     <span class="comment">% from square distance to euclidean distance</span>
0151     dists = sqrt(dists);
0152 <span class="keyword">end</span>
0153 
0154 
0155 <span class="comment">%% Auxiliary functions</span>
0156 
0157 <a name="_sub1" href="#_subfunctions" class="code">function id = get_splitrule_id(s)</a>
0158 
0159 <span class="keyword">switch</span> s
0160     <span class="keyword">case</span> <span class="string">'suggest'</span>
0161         id = 5;
0162     <span class="keyword">case</span> <span class="string">'std'</span>
0163         id = 0;
0164     <span class="keyword">case</span> <span class="string">'midpt'</span>
0165         id = 1;
0166     <span class="keyword">case</span> <span class="string">'fair'</span>
0167         id = 2;
0168     <span class="keyword">case</span> <span class="string">'sl_midpt'</span>
0169         id = 3;
0170     <span class="keyword">case</span> <span class="string">'sl_fair'</span>
0171         id = 4;
0172     <span class="keyword">otherwise</span>
0173         error(<span class="string">'annerror:invalidarg'</span>, <span class="keyword">...</span>
0174             <span class="string">'Invalid split rule %s for annsearch'</span>, s);
0175 <span class="keyword">end</span>
0176 
0177 
0178 <a name="_sub2" href="#_subfunctions" class="code">function id = get_searchmethod_id(s)</a>
0179 
0180 <span class="keyword">switch</span> s
0181     <span class="keyword">case</span> <span class="string">'normal'</span>
0182         id = 0;
0183     <span class="keyword">case</span> <span class="string">'priority'</span>
0184         id = 1;
0185     <span class="keyword">otherwise</span>
0186         error(<span class="string">'annerror:invalidarg'</span>, <span class="keyword">...</span>
0187             <span class="string">'Invalid search method %s for annsearch'</span>, s);
0188 <span class="keyword">end</span>
0189 
0190 
0191 
0192 
0193 
0194 
0195</pre></div>
<hr><address>Generated on Wed 20-Sep-2006 12:43:11 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>