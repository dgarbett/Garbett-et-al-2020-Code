<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of slnlda</title>
  <meta name="keywords" content="slnlda">
  <meta name="description" content="SLNLDA Performs Nullspace-based Linear Discriminant Analysis">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">sltoolbox</a> &gt; <a href="index.html">subspace</a> &gt; slnlda.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for sltoolbox\subspace&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>slnlda
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>SLNLDA Performs Nullspace-based Linear Discriminant Analysis</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function T = slnlda(X, nums, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">SLNLDA Performs Nullspace-based Linear Discriminant Analysis

 $ Syntax $
   - T = slnlda(X, nums)
   - T = slnlda(X, nums, ...)

 $ Arguments $
   - X:        the training sample matrix
   - nums:     the numbers of samples in all classes
   - T:        the solved transform matrix

 $ Description $
   - T = slnlda(X, nums) performs nullspace LDA on the samples X using 
     default settings.

   - T = slnlda(X, nums, ...) performs nullspace LDA on the samples X
     with the specified properties.
     \*
     \t   Table 1.  The properties of Fisher Discriminant Analysis   \\
     \h     name    &amp;     description                                \\
           'prepca' &amp;  Whether to perform a preamble PCA to first 
                       reduce the dimensions to the samples' rank.
                       default = false.                              \\
           'pdimset' &amp;  The cell containing the arguments for determining
                        the dimension of the principal subspace (that is
                        the orthogonal complement of the nullspace)   \\
           'dimset'  &amp;  The cell containing the arguments for determining
                        the output feature dimension. default = {}.
                        (refer to sldim_by_eigval).                   \\
           'Sb'      &amp;  The pre-computed between-class scattering matrix
                        or the cell containing the arguments for 
                        computing the scatter matrix in the form
                        {type, ...}, which is input to slscatter.     \\
           'Sw'      &amp;  The pre-computed within-class scattering matrix
                        or the cell containing the arguments for 
                        computing the scatter matrix in the form
                        {type, ...}, which is input to slscatter.     \\
         'weights'   &amp;  The sample weights. default = [].             \\
     \*  

 $ Remarks $
   -# The function solves the transform in mainly following stages: 
      First, solve the null space of the between-class scattering, then
      project all samples onto the null space. Finally, a PCA-step is 
      conducted to maximize the between-class scattering on nullspace.
      
   -# If Sw or its computing rule is given, the null space is  directly 
      solved from Sw, otherwise the null space is solved from within class 
      differences. If Sb is given, the between-class scattering on null 
      space is computed by directly applying the null space projection
      to Sb, otherwise, Sb is computed from components on nullspace. If 
      both Sb and Sw are given, then the samples are not used in the 
      function. In this cases, you can simply input an empty X. 

   -# If both Sb and Sw are given, the pre-pca step will not be conducted.
      no matter whether prepca is true or false.

 $ History $
   - Created by Dahua Lin on May 1st, 2006
   - Modified by Dahua Lin on Sep 10th, 2006
       - replace sladd by sladdvec and slmul by slmulvec to increase 
         efficiency</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../sltoolbox/core/sladdvec.html" class="code" title="function Y = sladdvec(X, v, d)">sladdvec</a>	SLADDVEC adds a vector to columns or rows of a matrix</li><li><a href="../../sltoolbox/core/slmulvec.html" class="code" title="function Y = slmulvec(X, v, d)">slmulvec</a>	SLMULVEC multiplies a vector to columns or rows of a matrix</li><li><a href="../../sltoolbox/core/slsymeig.html" class="code" title="function [evals, evecs] = slsymeig(A, k, ord)">slsymeig</a>	SLSYMEIG Compute the eigenvalues and eigenvectors for symmetric matrix</li><li><a href="../../sltoolbox/stat/slmeans.html" class="code" title="function varargout = slmeans(X, w, nums)">slmeans</a>	SLMEANS Compute the mean vectors</li><li><a href="sldim_by_eigval.html" class="code" title="function d = sldim_by_eigval(eigvals, sch, varargin)">sldim_by_eigval</a>	SLDIM_BY_EIGVAL Determines the dimension of principal subspace by eigenvalues</li><li><a href="slnullspace.html" class="code" title="function [V, Vc] = slnullspace(tar, varargin)">slnullspace</a>	SLRANGESPACE Determines the null-space of the range of X</li><li><a href="slpca.html" class="code" title="function S = slpca(X, varargin)">slpca</a>	SLPCA Learns a PCA model from training samples</li><li><a href="slscatter.html" class="code" title="function S = slscatter(X, type, varargin)">slscatter</a>	SLSCATTER Compute the scatter matrix</li><li><a href="../../sltoolbox/utils/raise_lackinput.html" class="code" title="function raise_lackinput(funcname, nmin)">raise_lackinput</a>	RAISE_LACKINPUT Raises an error indicating lack of input argument</li><li><a href="../../sltoolbox/utils/slnums2bounds.html" class="code" title="function [spos, epos] = slnums2bounds(nums)">slnums2bounds</a>	SLNUMS2BOUNDS Compute the index-boundaries from section sizes</li><li><a href="../../sltoolbox/utils/slparseprops.html" class="code" title="function P = slparseprops(P0, varargin)">slparseprops</a>	SLPARSEPROPS Parses input parameters</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="sllda.html" class="code" title="function T = sllda(X, nums, method, varargin)">sllda</a>	SLLDA Trains a Linear Discriminant Model using specified method</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Y = make_weighted_withinclass_diffvecs(X, w, nums)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function T = slnlda(X, nums, varargin)</a>
0002 <span class="comment">%SLNLDA Performs Nullspace-based Linear Discriminant Analysis</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% $ Syntax $</span>
0005 <span class="comment">%   - T = slnlda(X, nums)</span>
0006 <span class="comment">%   - T = slnlda(X, nums, ...)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% $ Arguments $</span>
0009 <span class="comment">%   - X:        the training sample matrix</span>
0010 <span class="comment">%   - nums:     the numbers of samples in all classes</span>
0011 <span class="comment">%   - T:        the solved transform matrix</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% $ Description $</span>
0014 <span class="comment">%   - T = slnlda(X, nums) performs nullspace LDA on the samples X using</span>
0015 <span class="comment">%     default settings.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%   - T = slnlda(X, nums, ...) performs nullspace LDA on the samples X</span>
0018 <span class="comment">%     with the specified properties.</span>
0019 <span class="comment">%     \*</span>
0020 <span class="comment">%     \t   Table 1.  The properties of Fisher Discriminant Analysis   \\</span>
0021 <span class="comment">%     \h     name    &amp;     description                                \\</span>
0022 <span class="comment">%           'prepca' &amp;  Whether to perform a preamble PCA to first</span>
0023 <span class="comment">%                       reduce the dimensions to the samples' rank.</span>
0024 <span class="comment">%                       default = false.                              \\</span>
0025 <span class="comment">%           'pdimset' &amp;  The cell containing the arguments for determining</span>
0026 <span class="comment">%                        the dimension of the principal subspace (that is</span>
0027 <span class="comment">%                        the orthogonal complement of the nullspace)   \\</span>
0028 <span class="comment">%           'dimset'  &amp;  The cell containing the arguments for determining</span>
0029 <span class="comment">%                        the output feature dimension. default = {}.</span>
0030 <span class="comment">%                        (refer to sldim_by_eigval).                   \\</span>
0031 <span class="comment">%           'Sb'      &amp;  The pre-computed between-class scattering matrix</span>
0032 <span class="comment">%                        or the cell containing the arguments for</span>
0033 <span class="comment">%                        computing the scatter matrix in the form</span>
0034 <span class="comment">%                        {type, ...}, which is input to slscatter.     \\</span>
0035 <span class="comment">%           'Sw'      &amp;  The pre-computed within-class scattering matrix</span>
0036 <span class="comment">%                        or the cell containing the arguments for</span>
0037 <span class="comment">%                        computing the scatter matrix in the form</span>
0038 <span class="comment">%                        {type, ...}, which is input to slscatter.     \\</span>
0039 <span class="comment">%         'weights'   &amp;  The sample weights. default = [].             \\</span>
0040 <span class="comment">%     \*</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% $ Remarks $</span>
0043 <span class="comment">%   -# The function solves the transform in mainly following stages:</span>
0044 <span class="comment">%      First, solve the null space of the between-class scattering, then</span>
0045 <span class="comment">%      project all samples onto the null space. Finally, a PCA-step is</span>
0046 <span class="comment">%      conducted to maximize the between-class scattering on nullspace.</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%   -# If Sw or its computing rule is given, the null space is  directly</span>
0049 <span class="comment">%      solved from Sw, otherwise the null space is solved from within class</span>
0050 <span class="comment">%      differences. If Sb is given, the between-class scattering on null</span>
0051 <span class="comment">%      space is computed by directly applying the null space projection</span>
0052 <span class="comment">%      to Sb, otherwise, Sb is computed from components on nullspace. If</span>
0053 <span class="comment">%      both Sb and Sw are given, then the samples are not used in the</span>
0054 <span class="comment">%      function. In this cases, you can simply input an empty X.</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%   -# If both Sb and Sw are given, the pre-pca step will not be conducted.</span>
0057 <span class="comment">%      no matter whether prepca is true or false.</span>
0058 <span class="comment">%</span>
0059 <span class="comment">% $ History $</span>
0060 <span class="comment">%   - Created by Dahua Lin on May 1st, 2006</span>
0061 <span class="comment">%   - Modified by Dahua Lin on Sep 10th, 2006</span>
0062 <span class="comment">%       - replace sladd by sladdvec and slmul by slmulvec to increase</span>
0063 <span class="comment">%         efficiency</span>
0064 <span class="comment">%</span>
0065 
0066 
0067 <span class="comment">%% parse and verify input arguments</span>
0068 
0069 <span class="keyword">if</span> nargin &lt; 2
0070     <a href="../../sltoolbox/utils/raise_lackinput.html" class="code" title="function raise_lackinput(funcname, nmin)">raise_lackinput</a>(<span class="string">'slfld'</span>, 2);
0071 <span class="keyword">end</span>
0072 
0073 <span class="comment">% check size</span>
0074 
0075 <span class="keyword">if</span> ~isempty(X)    
0076     <span class="keyword">if</span> ndims(X) ~= 2
0077         error(<span class="string">'sltoolbox:invaliddims'</span>, <span class="keyword">...</span>
0078             <span class="string">'The sample matrix X should be a 2D matrix'</span>);
0079     <span class="keyword">end</span>
0080     [d, n] = size(X);
0081     
0082     k = length(nums);
0083     <span class="keyword">if</span> ~isequal(size(nums), [1, k]);
0084         error(<span class="string">'sltoolbox:invaliddims'</span>, <span class="keyword">...</span>
0085             <span class="string">'The nums vector should be a row vector'</span>);
0086     <span class="keyword">end</span>
0087     <span class="keyword">if</span> sum(nums) ~= n
0088         error(<span class="string">'sltoolbox:sizmismatch'</span>, <span class="keyword">...</span>
0089             <span class="string">'The total number in nums is not consistent with that in X'</span>);
0090     <span class="keyword">end</span>
0091 <span class="keyword">end</span>
0092 
0093 <span class="comment">% check options</span>
0094 
0095 opts.prepca = false;
0096 opts.pdimset = {};
0097 opts.dimset = {};
0098 opts.Sb = {<span class="string">'Sb'</span>};
0099 opts.Sw = {<span class="string">'Sw'</span>};
0100 opts.weights = [];
0101 opts = <a href="../../sltoolbox/utils/slparseprops.html" class="code" title="function P = slparseprops(P0, varargin)">slparseprops</a>(opts, varargin{:});
0102 
0103 has_Sb = ~isempty(opts.Sb) &amp;&amp; isnumeric(opts.Sb);
0104 has_Sw = ~isempty(opts.Sw) &amp;&amp; isnumeric(opts.Sw);
0105 <span class="keyword">if</span> has_Sb &amp;&amp; has_Sw
0106     use_samples = false;
0107     d = size(opts.Sw, 1);
0108     
0109     <span class="keyword">if</span> ~isequal(size(opts.Sb), [d, d]) || ~isequal(size(opts.Sw), [d, d])
0110         error(<span class="string">'sltoolbox:sizmismatch'</span>, <span class="keyword">...</span>
0111             <span class="string">'Size consistency in Sb and Sw'</span>);
0112     <span class="keyword">end</span>
0113         
0114 <span class="keyword">else</span>
0115     <span class="keyword">if</span> isempty(X)
0116         error(<span class="string">'sltoolbox:invalidargs'</span>, <span class="keyword">...</span>
0117             <span class="string">'The samples cannot be empty when Sb or Sw is not pre-computed'</span>);
0118     <span class="keyword">end</span>
0119     use_samples = true;
0120     <span class="keyword">if</span> (has_Sb &amp;&amp; ~isequal(size(opts.Sb), [d, d])) || (has_Sw &amp;&amp; ~isequal(size(opts.Sw), [d, d]))
0121         error(<span class="string">'sltoolbox:sizmismatch'</span>, <span class="keyword">...</span>
0122             <span class="string">'Size consistency in Sb and Sw'</span>);
0123     <span class="keyword">end</span>
0124     
0125 <span class="keyword">end</span>
0126 w = opts.weights;
0127 
0128 
0129 <span class="comment">%% Compute</span>
0130 
0131 <span class="comment">%% Step 0: Pre-PCA</span>
0132 pca_computed = false;
0133 <span class="keyword">if</span> use_samples &amp;&amp; opts.prepca
0134     SPCA = <a href="slpca.html" class="code" title="function S = slpca(X, varargin)">slpca</a>(X, <span class="string">'weights'</span>, w);
0135     X = SPCA.P' * <a href="../../sltoolbox/core/sladdvec.html" class="code" title="function Y = sladdvec(X, v, d)">sladdvec</a>(X, -SPCA.vmean, 1);
0136     pca_computed = true;
0137 <span class="keyword">end</span>
0138 
0139 <span class="comment">%% Step 1: Solve Null Space</span>
0140 
0141 <span class="keyword">if</span> has_Sw
0142     PN = <a href="slnullspace.html" class="code" title="function [V, Vc] = slnullspace(tar, varargin)">slnullspace</a>({<span class="string">'cov'</span>, opts.Sw}, opts.pdimset{:});
0143 <span class="keyword">elseif</span> ~isempty(opts.Sw) &amp;&amp; ~isequal(opts.Sw, {<span class="string">'Sw'</span>})
0144     Sw = <a href="slscatter.html" class="code" title="function S = slscatter(X, type, varargin)">slscatter</a>(X, opts.Sw{:}, <span class="string">'sweights'</span>, w, <span class="string">'nums'</span>, nums);
0145     PN = <a href="slnullspace.html" class="code" title="function [V, Vc] = slnullspace(tar, varargin)">slnullspace</a>({<span class="string">'cov'</span>, Sw}, opts.pdimset{:});
0146     clear Sw;
0147 <span class="keyword">else</span> 
0148     PN = <a href="slnullspace.html" class="code" title="function [V, Vc] = slnullspace(tar, varargin)">slnullspace</a>(<a href="#_sub1" class="code" title="subfunction Y = make_weighted_withinclass_diffvecs(X, w, nums)">make_weighted_withinclass_diffvecs</a>(X, w, nums), <span class="keyword">...</span>
0149         opts.pdimset{:});
0150 <span class="keyword">end</span>
0151 
0152 <span class="keyword">if</span> pca_computed
0153     T1 = SPCA.P * PN;
0154     clear SPCA PN;
0155 <span class="keyword">else</span>
0156     T1 = PN;
0157     clear PN;
0158 <span class="keyword">end</span>
0159 
0160 
0161 <span class="comment">%% Step 2: Compute the second-stage transform</span>
0162 
0163 <span class="keyword">if</span> has_Sb
0164     WSb = T1' * opts.Sb * T1;
0165 <span class="keyword">else</span>
0166     X = T1' * X;
0167     WSb = <a href="slscatter.html" class="code" title="function S = slscatter(X, type, varargin)">slscatter</a>(X, opts.Sb{:}, <span class="string">'sweights'</span>, w, <span class="string">'nums'</span>, nums);
0168 <span class="keyword">end</span>
0169 [evs, T2] = <a href="../../sltoolbox/core/slsymeig.html" class="code" title="function [evals, evecs] = slsymeig(A, k, ord)">slsymeig</a>(WSb);
0170 rk2 = <a href="sldim_by_eigval.html" class="code" title="function d = sldim_by_eigval(eigvals, sch, varargin)">sldim_by_eigval</a>(evs, opts.dimset{:});
0171 T2 = T2(:, 1:rk2);
0172 
0173 <span class="comment">%% Integrate the transforms</span>
0174 
0175 T = T1 * T2;
0176 
0177 
0178 <span class="comment">%% The function for making the weighted difference vectors</span>
0179 <a name="_sub1" href="#_subfunctions" class="code">function Y = make_weighted_withinclass_diffvecs(X, w, nums)</a>
0180 
0181 mvs = <a href="../../sltoolbox/stat/slmeans.html" class="code" title="function varargout = slmeans(X, w, nums)">slmeans</a>(X, w, nums);
0182 Y = X;
0183 [sp, ep] = <a href="../../sltoolbox/utils/slnums2bounds.html" class="code" title="function [spos, epos] = slnums2bounds(nums)">slnums2bounds</a>(nums);
0184 k = length(nums);
0185 <span class="keyword">for</span> i = 1 : k
0186     Y(:, sp(i):ep(i)) = <a href="../../sltoolbox/core/sladdvec.html" class="code" title="function Y = sladdvec(X, v, d)">sladdvec</a>(X(:, sp(i):ep(i)), -mvs(:,i), 1);
0187 <span class="keyword">end</span>
0188 
0189 <span class="keyword">if</span> ~isempty(w)
0190     Y = <a href="../../sltoolbox/core/slmulvec.html" class="code" title="function Y = slmulvec(X, v, d)">slmulvec</a>(Y, sqrt(max(w, 0)), 2);
0191 <span class="keyword">end</span>
0192</pre></div>
<hr><address>Generated on Wed 20-Sep-2006 12:43:11 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>