<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sldlda</title>
  <meta name="keywords" content="sldlda">
  <meta name="description" content="SLDLDA Performs Direct Linear Discriminant Analysis">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">sltoolbox</a> &gt; <a href="index.html">subspace</a> &gt; sldlda.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for sltoolbox\subspace&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>sldlda
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>SLDLDA Performs Direct Linear Discriminant Analysis</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function T = sldlda(X, nums, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">SLDLDA Performs Direct Linear Discriminant Analysis

 $ Syntax $
   - T = sldlda(X, nums)
   - T = sldlda(X, nums, ...)

 $ Arguments $
   - X:        the training sample matrix
   - nums:     the numbers of samples in all classes
   - T:        the solved transform matrix

 $ Description $
   - T = sldlda(X, nums) performs direct LDA on the samples X using 
     default settings.

   - T = sldlda(X, nums, ...) performs direct LDA on the samples X
     with the specified properties.
     \*
     \t   Table 1.  The properties of Fisher Discriminant Analysis   \\
     \h     name     &amp;     description                                \\
           'pdimset' &amp;  The cell containing the arguments for determining
                        the range space of Sb. They will be input to
                        slrangespace for dimension determination.
           'whiten'  &amp;  The cell containing the arguments for computing 
                        the whitening transform in 2nd stage. They will
                        input to slwhiten_from_cov.
                        default = {}.       \\
           'Sb'      &amp;  The pre-computed between-class scattering matrix
                        or the cell containing the arguments for 
                        computing the scatter matrix in the form
                        {type, ...}, which is input to slscatter.     \\
           'Sw'      &amp;  The pre-computed within-class scattering matrix
                        or the cell containing the arguments for 
                        computing the scatter matrix in the form
                        {type, ...}, which is input to slscatter.     \\
         'weights'   &amp;  The sample weights. default = [].             \\
     \*  

 $ Remarks $
   -# The function solves the transform in mainly following stages: 
      First solves the range space of between-class scattering, 
      projecting all samples onto it. Then, solve the whitening transform
      of the projected within-class scattering.
      
   -# If Sb or its computing rule is given, the range space is  directly 
      solved from Sb, otherwise the null space is solved from class 
      centers. If both Sb and Sw are given, then the samples are not 
      used in the function. In this cases, you can simply input an empty X. 

   -# If both Sb and Sw are given, the pre-pca step will not be conducted.
      no matter whether prepca is true or false.

 $ History $
   - Created by Dahua Lin on May 1st, 2006</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../sltoolbox/core/slmulvec.html" class="code" title="function Y = slmulvec(X, v, d)">slmulvec</a>	SLMULVEC multiplies a vector to columns or rows of a matrix</li><li><a href="../../sltoolbox/stat/slmeans.html" class="code" title="function varargout = slmeans(X, w, nums)">slmeans</a>	SLMEANS Compute the mean vectors</li><li><a href="../../sltoolbox/stat/slwhiten_from_cov.html" class="code" title="function W = slwhiten_from_cov(C, method, varargin)">slwhiten_from_cov</a>	SLWHITEN_FROM_COV Compute the whitening transform from covariance matrix</li><li><a href="slrangespace.html" class="code" title="function [U, Uc] = slrangespace(tar, varargin)">slrangespace</a>	SLRANGESPACE Determines the subspace of the range of X</li><li><a href="slscatter.html" class="code" title="function S = slscatter(X, type, varargin)">slscatter</a>	SLSCATTER Compute the scatter matrix</li><li><a href="../../sltoolbox/utils/raise_lackinput.html" class="code" title="function raise_lackinput(funcname, nmin)">raise_lackinput</a>	RAISE_LACKINPUT Raises an error indicating lack of input argument</li><li><a href="../../sltoolbox/utils/slnums2bounds.html" class="code" title="function [spos, epos] = slnums2bounds(nums)">slnums2bounds</a>	SLNUMS2BOUNDS Compute the index-boundaries from section sizes</li><li><a href="../../sltoolbox/utils/slparseprops.html" class="code" title="function P = slparseprops(P0, varargin)">slparseprops</a>	SLPARSEPROPS Parses input parameters</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="sllda.html" class="code" title="function T = sllda(X, nums, method, varargin)">sllda</a>	SLLDA Trains a Linear Discriminant Model using specified method</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [Xc, wc] = get_weighted_centers(X, w, nums)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function T = sldlda(X, nums, varargin)</a>
0002 <span class="comment">%SLDLDA Performs Direct Linear Discriminant Analysis</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% $ Syntax $</span>
0005 <span class="comment">%   - T = sldlda(X, nums)</span>
0006 <span class="comment">%   - T = sldlda(X, nums, ...)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% $ Arguments $</span>
0009 <span class="comment">%   - X:        the training sample matrix</span>
0010 <span class="comment">%   - nums:     the numbers of samples in all classes</span>
0011 <span class="comment">%   - T:        the solved transform matrix</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% $ Description $</span>
0014 <span class="comment">%   - T = sldlda(X, nums) performs direct LDA on the samples X using</span>
0015 <span class="comment">%     default settings.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%   - T = sldlda(X, nums, ...) performs direct LDA on the samples X</span>
0018 <span class="comment">%     with the specified properties.</span>
0019 <span class="comment">%     \*</span>
0020 <span class="comment">%     \t   Table 1.  The properties of Fisher Discriminant Analysis   \\</span>
0021 <span class="comment">%     \h     name     &amp;     description                                \\</span>
0022 <span class="comment">%           'pdimset' &amp;  The cell containing the arguments for determining</span>
0023 <span class="comment">%                        the range space of Sb. They will be input to</span>
0024 <span class="comment">%                        slrangespace for dimension determination.</span>
0025 <span class="comment">%           'whiten'  &amp;  The cell containing the arguments for computing</span>
0026 <span class="comment">%                        the whitening transform in 2nd stage. They will</span>
0027 <span class="comment">%                        input to slwhiten_from_cov.</span>
0028 <span class="comment">%                        default = {}.       \\</span>
0029 <span class="comment">%           'Sb'      &amp;  The pre-computed between-class scattering matrix</span>
0030 <span class="comment">%                        or the cell containing the arguments for</span>
0031 <span class="comment">%                        computing the scatter matrix in the form</span>
0032 <span class="comment">%                        {type, ...}, which is input to slscatter.     \\</span>
0033 <span class="comment">%           'Sw'      &amp;  The pre-computed within-class scattering matrix</span>
0034 <span class="comment">%                        or the cell containing the arguments for</span>
0035 <span class="comment">%                        computing the scatter matrix in the form</span>
0036 <span class="comment">%                        {type, ...}, which is input to slscatter.     \\</span>
0037 <span class="comment">%         'weights'   &amp;  The sample weights. default = [].             \\</span>
0038 <span class="comment">%     \*</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% $ Remarks $</span>
0041 <span class="comment">%   -# The function solves the transform in mainly following stages:</span>
0042 <span class="comment">%      First solves the range space of between-class scattering,</span>
0043 <span class="comment">%      projecting all samples onto it. Then, solve the whitening transform</span>
0044 <span class="comment">%      of the projected within-class scattering.</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%   -# If Sb or its computing rule is given, the range space is  directly</span>
0047 <span class="comment">%      solved from Sb, otherwise the null space is solved from class</span>
0048 <span class="comment">%      centers. If both Sb and Sw are given, then the samples are not</span>
0049 <span class="comment">%      used in the function. In this cases, you can simply input an empty X.</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   -# If both Sb and Sw are given, the pre-pca step will not be conducted.</span>
0052 <span class="comment">%      no matter whether prepca is true or false.</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% $ History $</span>
0055 <span class="comment">%   - Created by Dahua Lin on May 1st, 2006</span>
0056 <span class="comment">%</span>
0057 
0058 <span class="comment">%% parse and verify input arguments</span>
0059 
0060 <span class="keyword">if</span> nargin &lt; 2
0061     <a href="../../sltoolbox/utils/raise_lackinput.html" class="code" title="function raise_lackinput(funcname, nmin)">raise_lackinput</a>(<span class="string">'slfld'</span>, 2);
0062 <span class="keyword">end</span>
0063 
0064 <span class="comment">% check size</span>
0065 
0066 <span class="keyword">if</span> ~isempty(X)    
0067     <span class="keyword">if</span> ndims(X) ~= 2
0068         error(<span class="string">'sltoolbox:invaliddims'</span>, <span class="keyword">...</span>
0069             <span class="string">'The sample matrix X should be a 2D matrix'</span>);
0070     <span class="keyword">end</span>
0071     [d, n] = size(X);
0072     
0073     k = length(nums);
0074     <span class="keyword">if</span> ~isequal(size(nums), [1, k]);
0075         error(<span class="string">'sltoolbox:invaliddims'</span>, <span class="keyword">...</span>
0076             <span class="string">'The nums vector should be a row vector'</span>);
0077     <span class="keyword">end</span>
0078     <span class="keyword">if</span> sum(nums) ~= n
0079         error(<span class="string">'sltoolbox:sizmismatch'</span>, <span class="keyword">...</span>
0080             <span class="string">'The total number in nums is not consistent with that in X'</span>);
0081     <span class="keyword">end</span>
0082 <span class="keyword">end</span>
0083 
0084 <span class="comment">% check options</span>
0085 opts.pdimset = {};
0086 opts.whiten = {};
0087 opts.Sb = {<span class="string">'Sb'</span>};
0088 opts.Sw = {<span class="string">'Sw'</span>};
0089 opts.weights = [];
0090 opts = <a href="../../sltoolbox/utils/slparseprops.html" class="code" title="function P = slparseprops(P0, varargin)">slparseprops</a>(opts, varargin{:});
0091 
0092 has_Sb = ~isempty(opts.Sb) &amp;&amp; isnumeric(opts.Sb);
0093 has_Sw = ~isempty(opts.Sw) &amp;&amp; isnumeric(opts.Sw);
0094 <span class="keyword">if</span> has_Sb &amp;&amp; has_Sw
0095     d = size(opts.Sw, 1);
0096     
0097     <span class="keyword">if</span> ~isequal(size(opts.Sb), [d, d]) || ~isequal(size(opts.Sw), [d, d])
0098         error(<span class="string">'sltoolbox:sizmismatch'</span>, <span class="keyword">...</span>
0099             <span class="string">'Size consistency in Sb and Sw'</span>);
0100     <span class="keyword">end</span>
0101         
0102 <span class="keyword">else</span>
0103     <span class="keyword">if</span> isempty(X)
0104         error(<span class="string">'sltoolbox:invalidargs'</span>, <span class="keyword">...</span>
0105             <span class="string">'The samples cannot be empty when Sb or Sw is not pre-computed'</span>);
0106     <span class="keyword">end</span>
0107     <span class="keyword">if</span> (has_Sb &amp;&amp; ~isequal(size(opts.Sb), [d, d])) || (has_Sw &amp;&amp; ~isequal(size(opts.Sw), [d, d]))
0108         error(<span class="string">'sltoolbox:sizmismatch'</span>, <span class="keyword">...</span>
0109             <span class="string">'Size consistency in Sb and Sw'</span>);
0110     <span class="keyword">end</span>
0111     
0112 <span class="keyword">end</span>
0113 w = opts.weights;
0114 
0115 <span class="comment">%% Step 1: Compute range space of Sb</span>
0116 
0117 <span class="keyword">if</span> has_Sb
0118     T1 = <a href="slrangespace.html" class="code" title="function [U, Uc] = slrangespace(tar, varargin)">slrangespace</a>({<span class="string">'cov'</span>, opts.Sb}, opts.pdimset{:});
0119 <span class="keyword">elseif</span> ~isempty(opts.Sb) &amp;&amp; ~isequal(opts.Sb, {<span class="string">'Sb'</span>})
0120     Sb = <a href="slscatter.html" class="code" title="function S = slscatter(X, type, varargin)">slscatter</a>({<span class="string">'cov'</span>, X}, opts.Sb{:}, <span class="string">'sweights'</span>, w, <span class="string">'nums'</span>, nums);
0121     T1 = <a href="slrangespace.html" class="code" title="function [U, Uc] = slrangespace(tar, varargin)">slrangespace</a>(Sb, opts.pdimset{:});
0122     clear Sb;
0123 <span class="keyword">else</span>
0124     Xc = <a href="#_sub1" class="code" title="subfunction [Xc, wc] = get_weighted_centers(X, w, nums)">get_weighted_centers</a>(X, w, nums);
0125     T1 = <a href="slrangespace.html" class="code" title="function [U, Uc] = slrangespace(tar, varargin)">slrangespace</a>(Xc, opts.pdimset{:});
0126     clear Xc wc;
0127 <span class="keyword">end</span>
0128 
0129 
0130 <span class="comment">%% Step 2: Compute the whiten transform for Sw on range space</span>
0131 
0132 <span class="keyword">if</span> has_Sw
0133     PSw = T1' * opts.Sw * T1;
0134 <span class="keyword">else</span>
0135     X = T1' * X;
0136     PSw = <a href="slscatter.html" class="code" title="function S = slscatter(X, type, varargin)">slscatter</a>(X, opts.Sw{:}, <span class="string">'sweights'</span>, w, <span class="string">'nums'</span>, nums);
0137 <span class="keyword">end</span>
0138 T2 = <a href="../../sltoolbox/stat/slwhiten_from_cov.html" class="code" title="function W = slwhiten_from_cov(C, method, varargin)">slwhiten_from_cov</a>(PSw, opts.whiten{:});
0139 T2 = flipdim(T2, 2);
0140 
0141 <span class="comment">%% Integrate the transforms</span>
0142 
0143 T = T1 * T2;
0144 
0145 
0146 <span class="comment">%% The function for computing weighted centers</span>
0147 <a name="_sub1" href="#_subfunctions" class="code">function [Xc, wc] = get_weighted_centers(X, w, nums)</a>
0148 
0149 Xc = <a href="../../sltoolbox/stat/slmeans.html" class="code" title="function varargout = slmeans(X, w, nums)">slmeans</a>(X, w, nums);
0150 <span class="keyword">if</span> isempty(w)
0151     wc = nums;
0152 <span class="keyword">else</span>
0153     k = length(nums);
0154     [sp, ep] = <a href="../../sltoolbox/utils/slnums2bounds.html" class="code" title="function [spos, epos] = slnums2bounds(nums)">slnums2bounds</a>(nums);
0155     wc = zeros(1, k);
0156     <span class="keyword">for</span> i = 1 : k
0157         wc(i) = sum(w(sp(i):ep(i)));
0158     <span class="keyword">end</span>
0159 <span class="keyword">end</span>
0160 wc = sqrt(max(wc, 0));
0161 Xc = <a href="../../sltoolbox/core/slmulvec.html" class="code" title="function Y = slmulvec(X, v, d)">slmulvec</a>(Xc, wc, 2);
0162 
0163</pre></div>
<hr><address>Generated on Wed 20-Sep-2006 12:43:11 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>